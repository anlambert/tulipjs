#ifndef LABELSRENDERER_H
#define LABELSRENDERER_H

#include <GL/gl.h>

#include <tulip/BoundingBox.h>
#include <tulip/Graph.h>
#include <tulip/StringProperty.h>
#include <tulip/LayoutProperty.h>
#include <tulip/SizeProperty.h>
#include <tulip/ColorProperty.h>
#include <tulip/BooleanProperty.h>

#include <texture-atlas.h>
#include <texture-font.h>

#include <vector>
#include <map>

#include "Camera.h"

typedef tlp::Vector<float,  5, double> Vec5f;

class GlShaderProgram;
class GlBuffer;

class LabelsRenderer {

public :

    static LabelsRenderer *instance();

    static LabelsRenderer *instance(const std::string &canvasId);

    static void setCurrentCanvasId(const std::string &canvasId) {
      _currentCanvasId = canvasId;
    }

    ~LabelsRenderer();

    void loadFontFromFile(const std::string &fontFile);

    void initFont();

    bool fontInit() const;

    std::string fontFile() const {
      return _fontFile;
    }

    void addNodeLabel(tlp::Graph *graph, tlp::node n);

    void setLabelsScaled(const bool labelsScaled) {
      _labelsScaled = labelsScaled;
    }

    bool labelsScaled() const {
      return _labelsScaled;
    }

    void setMinMaxSizes(float minSize, float maxSize) {
      _minSize = minSize;
      _maxSize = maxSize;
    }

    void setOcclusionTest(const bool occlusionTest) {
      _occlusionTest = occlusionTest;
    }

    void renderGraphNodesLabels(tlp::Graph *graph, const Camera &camera, const tlp::Color &selectionColor, bool billboarded = false, bool useDistanceField = false);

    void renderOneLabel(const Camera &camera, const std::string &text, const tlp::BoundingBox &renderingBox,
                        const tlp::Color &labelColor = tlp::Color::Black, const bool useDistanceField = true);

    void clearGraphNodesLabelsRenderingData(tlp::Graph *graph);

    void setGraphNodesLabelsToRender(tlp::Graph *graph, const std::vector<tlp::node> &labelsToRender) {
      _labelsToRender[graph] = labelsToRender;
    }

private :

    static std::map<std::string, LabelsRenderer *> _instances;
    static std::string _currentCanvasId;


    LabelsRenderer();

    void uploadTextureData(bool useDistanceField = true);

    float getTextAspectRatio(const std::wstring &text);

    std::pair<std::vector<Vec5f>, std::vector<unsigned short> > getLabelRenderingData(const std::string &text, float &aspectRatio);

    void getLineRenderingDataUnscaled(const std::wstring &line, std::vector<Vec5f> &renderingData, std::vector<unsigned short> &indices, tlp::BoundingBox &lineBB, float penY=0);

    tlp::BoundingBox getLabelRenderingBoxScaled(const std::vector<Vec5f> &labelRenderingData,
                                                unsigned int labelDataStartIdx,
                                                unsigned int labelDataCount,
                                                const tlp::BoundingBox &renderingBox,
                                                float aspectRatio);

    std::string _fontFile;

    GlShaderProgram *_labelsShader;
    texture_font_t*  _textureFont;
    texture_atlas_t* _textureAtlas;
    GLuint _textureAtlasDF;

    std::map<tlp::Graph *, std::vector<tlp::node> > _labelsToRender;
    std::map<tlp::Graph *, std::map<tlp::node, std::pair<std::vector<Vec5f>, std::vector<unsigned short> > > > _nodeLabelRenderingData;
    std::map<tlp::Graph *, std::map<tlp::node, float> > _nodeLabelAspectRatio;
    std::map<tlp::Graph *, std::map<tlp::node, unsigned int> > _nodeLabelNbLines;

    bool _textureDataNeedUpload, _textureDataDFNeedUpload;
    bool _labelsScaled;
    float _minSize, _maxSize;
    bool _occlusionTest;
    std::set<wchar_t> _uploadedGlyphs;

};

#endif // LABELSRENDERER_H
